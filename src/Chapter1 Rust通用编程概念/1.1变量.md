## **1.1.1变量及可变性**

默认情况下变量是不可变的（immutable）。不过你也可以选择让变量是可变的（mutable）。

当变量不可变时，这意味着一旦一个值绑定到一个变量名后，就不能更改该值了。
```
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
保存文件，并使用 cargo run 运行程序。你将会收到一条错误信息error[E0384]: cannot assign twice to immutable variable `x`

我们可以通过在变量名前加上 mut 使得它们可变。增加 mut 的操作还向以后的读代码的人传达了代码的其他部分将会改变这个变量值。
```
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

### **1.1.2常量**

与不可变变量类似，常量（constant）是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异。

首先，常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变。常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须注明。
下面是一个常量声明的例子：
```
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
### **1.1.3遮蔽**
可以声明和前面变量具有相同名称的新变量。

此时第一个变量被第二个变量遮蔽（shadow），这意味着当我们使用变量时我们看到的会是第二个变量的值。

我们可以通过使用相同的变量名并重复使用 let 关键字来遮蔽变量，如下所示：
```
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```
遮蔽和将变量标记为 mut 不同，因为除非我们再次使用 let 关键字，否则若是我们不小心尝试重新赋值给这个变量，我们将得到一个编译错误。

而通过使用 let，我们可以对一个值进行一些转换，但在这些转换完成后，变量将是不可变的。

mut 和遮蔽之间的另一个区别是，因为我们在再次使用 let 关键字时有效地创建了一个新的变量，所以我们可以改变值的类型，但重复使用相同的名称。
