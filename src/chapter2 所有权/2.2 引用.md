## **2.2.1 引用变量**

通过引用可以实现对值的使用而不获取值的所有权，使用 & 来表明参数类型是一个引用。示例如下所示：

与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，*
```
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}


## **2.2.2可变引用变量**
正如变量在默认情况下是不可变的一样，引用也是不可变的。我们无法通过引用修改内容。

使用&mut可以创建一个可变引用变量，实现对引用变量的修改，如下所示：

```
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}

```

不过可变引用有一个很大的限制：在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败。

这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它由这三个行为造成：

1、两个或更多指针同时访问同一数据。

2、至少有一个指针被用来写入数据。

3、没有同步数据访问的机制。

注意，不能在拥有不可变引用的同时拥有可变引用。但是，拥有多个不可变引用是可以的。

